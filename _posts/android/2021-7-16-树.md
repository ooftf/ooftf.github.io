---
published: false
---

二分查找 O(log2n)
树查找  O(logn)
# 树

[二叉树，平衡二叉树，红黑树，b树，b+树，b*树的缺点与优点以及使用场景](https://blog.csdn.net/ff_simon/article/details/101055134)
## 二叉树
## 平衡二叉树
平衡二叉树（Balanced Binary Tree）又被称为AVL树（有别于AVL算法），且具有以下性质：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。这个方案很好的解决了二叉查找树退化成链表的问题，把插入，查找，删除的时间复杂度最好情况和最坏情况都维持在O(logN)。但是频繁旋转会使插入和删除牺牲掉O(logN)左右的时间，不过相对二叉查找树来说，时间上稳定了很多。

如下图所示：一个比较复则的平衡二叉树

![复杂的平衡二叉树](https://raw.githubusercontent.com/ooftf/Material/master/img/blog/20210731124041.png)
## 红黑树
[红黑树](https://www.jianshu.com/p/e136ec79235c) 这篇文章图有问题

虽然平衡树解决了二叉查找树退化为近似链表的缺点，能够把查找时间控制在 O(logn)，不过却不是最佳的，因为平衡树要求每个节点的左子树和右子树的高度差至多等于1，这个要求实在是太严了，导致每次进行插入/删除节点的时候，几乎都会破坏平衡树的第二个规则，进而我们都需要通过左旋和右旋来进行调整，使之再次成为一颗符合要求的平衡树。显然，如果在那种插入、删除很频繁的场景中，平衡树需要频繁着进行调整，这会使平衡树的性能大打折扣，为了解决这个问题，于是有了红黑树，红黑树具有如下特点：

### 红黑树定义和性质 
1. 每个节点或者是黑色，或者是红色。
2. 根节点是黑色。
3. 每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]
4. 如果一个节点是红色的，则它的子节点必须是黑色的。
5. 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。[这里指到叶子节点的路径]


如图：
![红黑树](https://raw.githubusercontent.com/ooftf/Material/master/img/blog/20210731130909.png)

java中使用到红黑树的有TreeSet和JDK1.8的HashMap

### HashMap 中的红黑树