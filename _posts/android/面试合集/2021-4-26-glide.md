# [glide](https://github.com/bumptech/glide)
[![Maven Central](https://maven-badges.herokuapp.com/maven-central/com.github.bumptech.glide/glide/badge.svg)](https://maven-badges.herokuapp.com/maven-central/com.github.bumptech.glide/glide)
### 配置
```gradle
repositories {
  google()
  mavenCentral()
}

dependencies {
  implementation 'com.github.bumptech.glide:glide:4.12.0'
  annotationProcessor 'com.github.bumptech.glide:compiler:4.12.0'
}
```


### Glide 是可以绑定 Activity 或者 Fragment 的生命周期的，那是如何实现的呢？
Glide 并没有直接使用 jetpack 的 Lifecycle ,可能是考虑到兼容性问题。 Glide 会在 Fragment 或者 Activity 内通过 FragmentManager 添加一个 SupportRequestManagerFragment 或者 RequestManagerFragment 用来感知 Fragment 或者 Activity 的声明周期；
SupportRequestManagerFragment 和 RequestManagerFragment 的内部实现是一致的，只不过SupportRequestManagerFragment继承的是 androidx.fragment.app.Fragment，RequestManagerFragment 继承的是 android.app.Fragment  
RequestManagerFragment 如果感知的是 Fragment 的生命周期，还会添加到 Activity 对应的  RequestManagerFragment 的 childRequestManagerFragments 内，因此 Fragment 的 Glide 请求不止能感知 Fragment 的生命周期还能感知 Activity的 声明周期
有关 Glide 生命周期的类如下： 
* com.bumptech.glide.manager.ActivityFragmentLifecycle
* com.bumptech.glide.manager.Lifecycle
* com.bumptech.glide.manager.LifecycleListener

其逻辑很简单就是观察者模式，监听了 onStart onStop onDestroy 三个声明周期
### 相关类
* RequestManager
  一个 RequestManager 用来管理一个 Activity 或者 Fragment 内的所有 Glide 请求，负责 Glide 请求的的生命周期管理 
* RequestManagerRetriever
  根据 Glide.with() 的 view,context,activity,fragment 等传值，找到或者创建对应的  RequestManager
* RequestManagerFragment，SupportRequestManagerFragment
  向 Activity 或者 Fragment 内添加 一个Fragment 用来感知其生命周期  

### 从源码的角度 Glide 加载图片的流程 （4.12.0）
```java
Glide.with(imageView).load("imageUrl").into(imageView)
```
1. Glide.with(imageView)
   ```java
     public static RequestManager with(@NonNull View view) {
       return getRetriever(view.getContext()).get(view);
     }
   ```
   * 展开 getRetriever(view.getContext())
     ```java
       private static RequestManagerRetriever getRetriever(@Nullable Context context) {
         ...
         return Glide.get(context).getRequestManagerRetriever();
       }
     ```
   * 展开 Glide.get(context)
     ```java
       public static Glide get(@NonNull Context context) {
         if (glide == null) {
           GeneratedAppGlideModule annotationGeneratedModule =
               getAnnotationGeneratedGlideModules(context.getApplicationContext());
           synchronized (Glide.class) {
             if (glide == null) {
               checkAndInitializeGlide(context, annotationGeneratedModule);
             }
           }
         }
     
         return glide;
       }
     ```
     checkAndInitializeGlide 的作用是 检查 创建 初始化 Glide对象  
     Glide.get(context) 总结来说就是获取到全局唯一的 Glide 对象  
   * Glide.getRequestManagerRetriever 就是获取到 全局唯一的 RequestManagerRetriever
   * 调用 RequestManagerRetriever.get(view) 获取到 view 所对应的 RequestManager
2. RequestManager.load("imageUrl")
   ```java
   public RequestBuilder<Drawable> load(@Nullable String string) {
       return asDrawable().load(string);
   }
   ```
   配置一些默认参数返回 RequestBuilder
3. Request.into(imageView)
    ```java
    public ViewTarget<ImageView, TranscodeType> into(@NonNull ImageView view) {
      ...
      return into(
          glideContext.buildImageViewTarget(view, transcodeClass),
          /*targetListener=*/ null,
          requestOptions,
          Executors.mainThreadExecutor());
    }    

    ```
   * glideContext.buildImageViewTarget(view, transcodeClass)
     transcodeClass 是最终结果的类型在此次调用中就是 Drawable.class   
     展开buildImageViewTarget
     ```java
     public <X> ViewTarget<ImageView, X> buildImageViewTarget(@NonNull ImageView imageView, @NonNull Class<X> transcodeClass) {
        return imageViewTargetFactory.buildTarget(imageView, transcodeClass);
     }
     ```
     展开ImageViewTargetFactory.buildTarget
     ```java
     public <Z> ViewTarget<ImageView, Z> buildTarget(
         @NonNull ImageView view, @NonNull Class<Z> clazz) {
       if (Bitmap.class.equals(clazz)) {
         return (ViewTarget<ImageView, Z>) new BitmapImageViewTarget(view);
       } else if (Drawable.class.isAssignableFrom(clazz)) {
         return (ViewTarget<ImageView, Z>) new DrawableImageViewTarget(view);
       } else {
         throw new IllegalArgumentException(
             "Unhandled class: " + clazz + ", try .as*(Class).transcode(ResourceTranscoder)");
       }
     }
     ```
     ```java
     public class DrawableImageViewTarget extends ImageViewTarget<Drawable> {
     
       public DrawableImageViewTarget(ImageView view) {
         super(view);
       }
     
       /** @deprecated Use {@link #waitForLayout()} instead. */
       // Public API.
       @SuppressWarnings({"unused", "deprecation"})
       @Deprecated
       public DrawableImageViewTarget(ImageView view, boolean waitForLayout) {
         super(view, waitForLayout);
       }
     
       @Override
       protected void setResource(@Nullable Drawable resource) {
         view.setImageDrawable(resource);
       }
     }     
     ```
   * into()
    ```java
     private <Y extends Target<TranscodeType>> Y into(
         @NonNull Y target,
         @Nullable RequestListener<TranscodeType> targetListener,
         BaseRequestOptions<?> options,
         Executor callbackExecutor) {
       Preconditions.checkNotNull(target);
       if (!isModelSet) {
         throw new IllegalArgumentException("You must call #load() before calling #into()");
       }
   
       Request request = buildRequest(target, targetListener, options, callbackExecutor);
   
       Request previous = target.getRequest();
       if (request.isEquivalentTo(previous)
           && !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) {
         // If the request is completed, beginning again will ensure the result is re-delivered,
         // triggering RequestListeners and Targets. If the request is failed, beginning again will
         // restart the request, giving it another chance to complete. If the request is already
         // running, we can let it continue running without interruption.
         if (!Preconditions.checkNotNull(previous).isRunning()) {
           // Use the previous request rather than the new one to allow for optimizations like skipping
           // setting placeholders, tracking and un-tracking Targets, and obtaining View dimensions
           // that are done in the individual Request.
           previous.begin();
         }
         return target;
       }
   
       requestManager.clear(target);
       target.setRequest(request);
       requestManager.track(target, request);
   
       return target;
     }   
    ```


### 关系
* 一个App 只有一个 Glide 对象 也只有一个 RequestManagerRetriever 对象
* 一个 Activity 或者 Fragment 对应一个 RequestManager 管理对应 Activity 或者 Fragment 的多个 Request 
* 每个 Request 就是一次加载图片请求
### AppGlideModule 分析


