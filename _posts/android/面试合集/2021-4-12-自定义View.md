---
layout: post
author: "ooftf"
tags: Android
top: true
---
# View
## View的移动
* 不改变布局参数(不会触发layout)
  1. scrollTo
  2. 传统动画和属性动画（translationX translationY）
* 改变布局参数(改变LayoutParams)

## 平滑滑动动画
* Scroller
* ObjectAnimator

## View 的事件分发

### 触摸事件是从哪里来的
1. InputEventReceiver.dispatchInputEvent
2. ViewRootImpl$WindowInputEventReceiver.onInputEvent
3. ViewRootImpl.enqueueInputEvent
4. ...
5. ViewRootImpl$ViewPostImeInputStage.processPointerEvent
6. (DecorView)View.dispatchPointerEvent
7. DecorView.dispatchTouchEvent
8. WindowCallbackWrapper.dispatchTouchEvent
9. Activity.dispatchTouchEvent
10. PhoneWindow.superDispatchTouchEvent
11. DecorView.superDispatchTouchEvent
12. ViewGroup.dispatchTouchEvent
13. ...

### 主要方法
* dispatchTouchEvent  
  是 touch 事件的入口也是出口，对于View来说整个 touch 事件都是在 dispatchTouchEvent 方法内执行的
* onInterceptTouchEvent  
  如果返回 false 后续事件就不会再调用 onInterceptTouchEvent
* setOnTouchEventListener  
  如果返回 true 代表消费这个事件，那么就不会再执行 onTouchEvent 方法,如果返回 false 则会调用 onTouchEvent
* onTouchEvent  
  控件的 onClickListener 就是在这个方法内调用的

特性

* 如果 ACTION_DOWN 事件, ViewGroup.onInterceptTouchEvent 返回 true 子 View 无法再接收同一序列的事件，事件交由 super.dispatchTouchEvent 处理
* 如果 ACTION_DWON 事件, ChildView.dispatchTouchEvent 返回 false 无法再接收同一序列的事件，事件交由 super.dispatchTouchEvent 处理
* 如果 ACTION_DWON 事件, ViewGroup.onInterceptTouchEvent 返回 false 并且 ChildView.dispatchTouchEvent 返回 true,同一序列事件才会交由 ChildView.dispatchTouchEvent 处理

```kotlin
//ViewGroup.dispatchTouchEvent伪代码
fun dispatchTouchEvent(ev:MotionEvent):Boolean{
    if (actionMasked == MotionEvent.ACTION_DOWN) {
        mFirstTouchTarget = null
    }
    if(MotionEvent.ACTION_DOWN || mFirstTouchTarget != null){
         if (!disallowIntercept) {
            intercepted = onInterceptTouchEvent(ev);
            ev.setAction(action); // restore action in case it was changed
         } else {
            intercepted = false;
         }
    }else{
        intercepted = false;
    }
    if(!intercepted){
        if(actionMasked == MotionEvent.ACTION_DOWN){
            if(child.dispatchTouchEvent(ev)){
                addTouchTarget(child)// mFirstTouchTarget赋值为TouchTarget的头节点
            }
        }
    }
    boolean handled = false;
    if(mFirstTouchTarget == null){ // onInterceptTouchEvent 拦截了代码 或者 childView.dispatchTouchEvent 返回false
        // 执行View的touch系列事件，具体代码就是View.dispatchTouchEvent
        if(!handled){
            handled = mOnTouchListener.onTouch(ev)
        }
        if(!handled){
            handled = onTouchEvent(ev)
        }
        
    }else{
        //有个避免ACTION_DOWN二次调用的逻辑没有写
        var handler
        while(mFirstTouchTarget.hasNext){
            if(child.dispatchTouchEvent(ev)){
                handler = true
            }
        }
        //执行TouchTarget链表内View的事件
    }
    return handler
}
```
分析上述代码
* 如果 onInterceptTouchEvent如果返回true -> mFirstTouchTarget = null   ->下个event不会进入onInterceptTouchEvent
* onInterceptTouchEvent返回false -> mFirstTouchTarget被赋值 -> event进入onInterceptTouchEvent
* 如果mFirstTouchTarget 为null 则会执行View的touch事件如果mFirstTouchTarget不为null则会执行TouchTarget之内的子View的touch事件
* 生成mFirstTouchTarget 链表的动作只有在  ACTION_DOWN  ACTION_POINTER_DOWN ACTION_HOVER_MOVE 事件产生
* 如果在 ACTION_DOWN 事件时子View的 dispatchTouchEvent 返回为false就会导致 该View没有加入到 mFirstTouchTarget链表中，就会导致后续接收不到事件
* mFirstTouchTarget 是否为null是由 ACTION_DOWN 时 onInterceptTouchEvent 和子 View dispatchTouchEvent的返回值决定的

问题：mFirstTouchTarget 为什么是个链表？一个事件可以由多个Child处理?


## 滑动冲突
###  常见的滑动冲突
* 外部滑动方向和内部滑动方向不一致
  根据滑动是水平滑动还是数值华东判断到底是由谁来拦截事件，最简单的是通过水平和竖直方向移动的距离来判断
  1. 外部拦截法
     重写父容器的onInterceptTouchEvent在内部做响应的拦截即可参考《Android开发探索艺术》408页
     伪代码如下
     ```java
         public boolean onInterceptTouchEvent(MotionEvent event) {
            boolean intercepted = false;
            int x = (int) event.getX();
            int y = (int) event.getY();
            switch (event.getAction()) {
            case MotionEvent.ACTION_DOWN: {
                intercepted = false;
                break;
            }
            case MotionEvent.ACTION_MOVE: {
                if (父容器需要当前点击事件) {
                    intercepted = true;
                } else {
                    intercepted = false;
                }
                break;
            }
            case MotionEvent.ACTION_UP: {
                intercepted = false;
                break;
            }
            default:
                break;
              }
              mLastXIntercept = x;
              mLastYIntercept = y;
              return intercepted;
          }
     ```
  2. 内部拦截法
     重写子元素的dispatchTouchEvent方法（思考：为什么不是onTouchEvent方法）配合requestDisallowInterceptTouchEvent
     伪代码如下
     ```java
        public boolean dispatchTouchEvent(MotionEvent event) {
            int x = (int) event.getX();
            int y = (int) event.getY();

            switch (event.getAction()) {
            case MotionEvent.ACTION_DOWN: {
                parent.requestDisallowInterceptTouchEvent(true);
                    break;
                }
                case MotionEvent.ACTION_MOVE: {
                    int deltaX = x - mLastX;
                    int deltaY = y - mLastY;
                    if (父容器需要此类点击事件)) {
                        parent.requestDisallowInterceptTouchEvent(false);
                    }
                    break;
                }
                case MotionEvent.ACTION_UP: {
                    break;
                }
                default:
                    break;
                }

                mLastX = x;
                mLastY = y;
                return super.dispatchTouchEvent(event);
            }
     ```
* 外部滑动方向和内部滑动方向一直
* 上面两种情况叠加嵌套
## 自定 View onMeasure onLayout onDraw
一般分为四种
1. 继承View重写onDraw方法
    采用这种方式需要自己支持wrap_content 并且padding也需要自己处理
    如果由线程或者动画要及时停止，参考View.OnDetachedFromWindow
2. 继承ViewGroup派生特殊的Layout
   需要适合的处理ViewGroup的 onMeasure onLayout 这两个过程
   需要考虑自己的padding和子View的margin和显隐状态
   一般LinearLayout等空间是默认不开启绘画功能的，所以在onDraw是无法进行绘制的，需要调用setWillNotDraw进行设置
3. 继承特定的View(比如TextView)
4. 继承特定的ViewGroup (比如LinearLayout)


## 
## onMeasuer
android.view.ViewGroup.measureChildWithMargins(ViewGroup.java:7028)
setMeasuredDimension
resolveSizeAndState


### 自定义属性（不用写了，应该都知道）
如何获取到系统属性？
----------
参考KvLayout


## view.post 为什么可以获取到 View 的宽高

```java
  public boolean post(Runnable action) {
        final AttachInfo attachInfo = mAttachInfo;
        if (attachInfo != null) { // attachInfo 不为 null 表示已经执行过 dispatchAttachedToWindow
            return attachInfo.mHandler.post(action);
        }
        getRunQueue().post(action);
        return true;
    }
```

```java
//ViewRootImpl.performTraversals 可知 执行完 dispatchAttachedToWindow 方法之后就会执行 performMeasuer 方法，而在此时通过  mRunQueue.executeActions(info.mHandler); 发送的 Messager 肯定在 performMeasuer 之后才执行所以可以获取到 宽高
void dispatchAttachedToWindow(AttachInfo info, int visibility) {
    mAttachInfo = info;
    if (mRunQueue != null) {
        mRunQueue.executeActions(info.mHandler);
        mRunQueue = null;
    }
}
```
## 优秀文章
[Android View绘制13问13答](https://www.cnblogs.com/punkisnotdead/p/5181821.html)






