---
layout: post
author: "ooftf"
tags: Android
---

# Process
## 什么是进程
进程系统进行资源分配和调度的基本单位，是程序在内存中的实例;进程之间内存相互独立

## 多进程应用的优点
* Android 对单个进程是有内存大小限制的，多进程可以申请更多的总内存，减少单个进程占用内存的大小
* 进程间崩溃不会相互影响
* APP保活（前台进程优先级比较高；进程优先级越高、单个进程占用内存越小被杀死的优先级越小）
## 常见的多进程案例
* 将 WebView 放入单独进程
* 图片选择器放入单独进程
* 将功能比较独立的功能放入单个进程，比如 网络日志查看、崩溃日志查看等功能
## 多进程会存在那些问题
* 进程间内存相互独立，无法相互访问
    * ActivityLifeCycleCallbacks 只能拿到各自进程Activity的生命周期
    * 单例等静态资源会存在多份
    * 多进程会初始化多个Application
    * sp多进程无法及时同步
* 多进程在同时读写文件的时候会出问题
    * sp
    * db
    * 文件读写

* WebView cookie 问题
    * 原生 CookieManager cookie 可以同步
    * X5  CookieManger cookie 不可以
* A 进程 startActivity 新 Activity 在哪个进程中
    ```xml
    <activity android:multiprocess="true"> 
    ```
    * 默认情况下，未指定进程就是主进程，如果指定了进程就会指定进程中 
    * multiprocess = true 的情况下从哪个进程启动就存在于哪个进程 
  
* [SharePreferences跨进程](https://ooftf.github.io/2021/06/18/SharedPreferences/)
    解决方案 ContentProvider 或者 Binder 桥接 或者 MMKV

## 如何使用多进程
```xml
<service android:name=".remote.RemoteService" android:process=":remote"/>
<service android:name=".remote.RemoteService" android:process="com.xxx.xxx.remote"/>
```
* 包含 : 的进程属于当前应用的私有进程，其他应用的组件不可以和他跑在同一个进程中
* 不包含 : 的进程属于全局进程，其他应用通过 ShareUID 方式可以和它跑在同一个进程中

Android 系统会为每一个应用分配一个唯一的 UID，具有相同 UID 的应用才能共享数据。两个应用通过 ShareUID 跑在同一个进程中是有要求的，需要这两个应用有相同的 ShareUID 并且签名相同才可以。在这种情况下，它们就在同一个进程，可以互相访问对方的私有数据比如 data 目录、组件信息、共享内存数据。


## Android IPC (Inter-Process Communication) 的几种方式
* Binder
    * ContentProvider（基于Binder）
    * Messenger  (轻量级AILD，使用方便)（基于Binder），如果不需要处理多线程，可以使用 Messenger 来实现接口;
* Intent
* 共享文件
* Socket
* 共享内存

6 种 IPC 方式优劣势比较

![6 种 IPC 方式优劣势比较](https://github.com/ooftf/ooftf.github.io/blob/master/images/ipc.jpg?raw=true)

### Messenger
Messenger 比使用 AIDL 更简单，因为 Messenger 会将所有服务调用加入队列。纯 AIDL 接口会同时向服务发送多个请求，那么服务就必须执行多线程处理。
对于大多数应用，服务无需执行多线程处理，因此使用 Messenger 可让服务一次处理一个调用。如果您的服务必须执行多线程处理，请使用 AIDL 来定义接口。

服务端代码
```kotlin
private const val MSG_SAY_HELLO = 1

class MessengerService : Service() {

    private lateinit var mMessenger: Messenger

    internal class IncomingHandler(
            context: Context,
            private val applicationContext: Context = context.applicationContext
    ) : Handler() {
        override fun handleMessage(msg: Message) {
            when (msg.what) {
                MSG_SAY_HELLO ->
                    Toast.makeText(applicationContext, "hello!", Toast.LENGTH_SHORT).show()
                else -> super.handleMessage(msg)
            }
        }
    }

    override fun onBind(intent: Intent): IBinder? {
        Toast.makeText(applicationContext, "binding", Toast.LENGTH_SHORT).show()
        mMessenger = Messenger(IncomingHandler(this))
        return mMessenger.binder
    }
}

```
客户端代码
```kotlin
class ActivityMessenger : Activity() {
    private var mService: Messenger? = null
    private var bound: Boolean = false
    private val mConnection = object : ServiceConnection {
        override fun onServiceConnected(className: ComponentName, service: IBinder) {
            mService = Messenger(service)
            bound = true
        }
        override fun onServiceDisconnected(className: ComponentName) {
            //当与服务的连接意外中断时，例如服务崩溃或被终止时，Android 系统会调用该方法。当客户端取消绑定时，系统不会调用该方法。
            mService = null
            bound = false
        }
    }
    fun sayHello(v: View) {
        if (!bound) return
        val msg: Message = Message.obtain(null, MSG_SAY_HELLO, 0, 0)
        try {
            mService?.send(msg)
        } catch (e: RemoteException) {
            e.printStackTrace()
        }

    }
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.main)
    }

    override fun onStart() {
        super.onStart()
        Intent(this, MessengerService::class.java).also { intent ->
            bindService(intent, mConnection, Context.BIND_AUTO_CREATE)
        }
    }

    override fun onStop() {
        super.onStop()
        if (bound) {
            unbindService(mConnection)
            bound = false
        }
    }
}
```

### Binder （下面都以 SimapleRemoteService 为例）
* 同一个进程使用 Binder 可以使用 (service as LocalBinder).speak() 强转的方式，如果是不同进程使用强转就会报错 java.lang.ClassCastException: android.os.BinderProxy cannot be cast to xxx.xxx.xxx.LocalBinder
* 如果是同一进程中的 Binder 调用，调用处和被调用处在同一线程中，如果是跨进程调用，服务端是在 Binder 线程池中执行的
* AIDL方法是在服务端的 Binder 线程池中执行
* 如果知道服务端方法是耗时的，那么就要避免在客户端的UI线程中访问这个远程方法
* 使用了 一次 copy_from_user 和 mmap 完成的跨进程操作 
  客户端将数据通过 copy_from_user Native 方法将数据从客户端进程 copy 到系统空间，然后通过 mmap 将系统空间和服务端进程 映射到同一块进程中。完成数据的传输


```java
/*
 * This file is auto-generated.  DO NOT MODIFY.
 */
package com.ooftf.demo.ipc.remote;
public interface SimapleRemoteService extends android.os.IInterface
{
  /** Default implementation for SimapleRemoteService. */
  public static class Default implements com.ooftf.demo.ipc.remote.SimapleRemoteService
  {
    /**
         * Demonstrates some basic types that you can use as parameters
         * and return values in AIDL.
         */
    @Override public boolean register(com.ooftf.demo.ipc.remote.ICallback callback) throws android.os.RemoteException
    {
      return false;
    }
    @Override
    public android.os.IBinder asBinder() {
      return null;
    }
  }
  /** Local-side IPC implementation stub class. */
  public static abstract class Stub extends android.os.Binder implements com.ooftf.demo.ipc.remote.SimapleRemoteService
  {
    private static final java.lang.String DESCRIPTOR = "com.ooftf.demo.ipc.remote.SimapleRemoteService";
    /** Construct the stub at attach it to the interface. */
    public Stub()
    {
      this.attachInterface(this, DESCRIPTOR);
    }
    /**
     * Cast an IBinder object into an com.ooftf.demo.ipc.remote.SimapleRemoteService interface,
     * generating a proxy if needed.
     */
    public static com.ooftf.demo.ipc.remote.SimapleRemoteService asInterface(android.os.IBinder obj)
    {
      if ((obj==null)) {
        return null;
      }
      android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);
      if (((iin!=null)&&(iin instanceof com.ooftf.demo.ipc.remote.SimapleRemoteService))) {
        return ((com.ooftf.demo.ipc.remote.SimapleRemoteService)iin);
      }
      return new com.ooftf.demo.ipc.remote.SimapleRemoteService.Stub.Proxy(obj);
    }
    @Override public android.os.IBinder asBinder()
    {
      return this;
    }
    @Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException
    {
      java.lang.String descriptor = DESCRIPTOR;
      switch (code)
      {
        case INTERFACE_TRANSACTION:
        {
          reply.writeString(descriptor);
          return true;
        }
        case TRANSACTION_register:
        {
          data.enforceInterface(descriptor);
          com.ooftf.demo.ipc.remote.ICallback _arg0;
          _arg0 = com.ooftf.demo.ipc.remote.ICallback.Stub.asInterface(data.readStrongBinder());
          boolean _result = this.register(_arg0);
          reply.writeNoException();
          reply.writeInt(((_result)?(1):(0)));
          return true;
        }
        default:
        {
          return super.onTransact(code, data, reply, flags);
        }
      }
    }
    private static class Proxy implements com.ooftf.demo.ipc.remote.SimapleRemoteService
    {
      private android.os.IBinder mRemote;
      Proxy(android.os.IBinder remote)
      {
        mRemote = remote;
      }
      @Override public android.os.IBinder asBinder()
      {
        return mRemote;
      }
      public java.lang.String getInterfaceDescriptor()
      {
        return DESCRIPTOR;
      }
      /**
           * Demonstrates some basic types that you can use as parameters
           * and return values in AIDL.
           */
      @Override public boolean register(com.ooftf.demo.ipc.remote.ICallback callback) throws android.os.RemoteException
      {
        android.os.Parcel _data = android.os.Parcel.obtain();
        android.os.Parcel _reply = android.os.Parcel.obtain();
        boolean _result;
        try {
          _data.writeInterfaceToken(DESCRIPTOR);
          _data.writeStrongBinder((((callback!=null))?(callback.asBinder()):(null)));
          boolean _status = mRemote.transact(Stub.TRANSACTION_register, _data, _reply, 0);
          if (!_status && getDefaultImpl() != null) {
            return getDefaultImpl().register(callback);
          }
          _reply.readException();
          _result = (0!=_reply.readInt());
        }
        finally {
          _reply.recycle();
          _data.recycle();
        }
        return _result;
      }
      public static com.ooftf.demo.ipc.remote.SimapleRemoteService sDefaultImpl;
    }
    static final int TRANSACTION_register = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);
    public static boolean setDefaultImpl(com.ooftf.demo.ipc.remote.SimapleRemoteService impl) {
      // Only one user of this interface can use this function
      // at a time. This is a heuristic to detect if two different
      // users in the same process use this function.
      if (Stub.Proxy.sDefaultImpl != null) {
        throw new IllegalStateException("setDefaultImpl() called twice");
      }
      if (impl != null) {
        Stub.Proxy.sDefaultImpl = impl;
        return true;
      }
      return false;
    }
    public static com.ooftf.demo.ipc.remote.SimapleRemoteService getDefaultImpl() {
      return Stub.Proxy.sDefaultImpl;
    }
  }
  /**
       * Demonstrates some basic types that you can use as parameters
       * and return values in AIDL.
       */
  public boolean register(com.ooftf.demo.ipc.remote.ICallback callback) throws android.os.RemoteException;
}

```

总结：Binnder 调用流程

0. 系统空间接收到链接请求后，利用 mmap 将部分系统空间和服务端用户空间，映射到同一块内存中
1. 通过和服务端 Service 建立 ServiceConnection 链接，获取到代理 IBinder 实际是 android.os.BinderProxy 对象
2. 通过 SimapleRemoteService.Stub.asInterface(service) 方法生成 SimapleRemoteService.Proxy 对象
3. 通过 SimapleRemoteService.Proxy 调用 SimapleRemoteService 接口的方法
4. 生成 _data 和 _reply 两个 Parcel, _data 封装入参，_reply 封装返回值
5. 调用 BinderProxy.transact 方法，传入 方法标识、_data、_reply 和 flag 四个字段
6. 调用 Native 方法 BinderProxy.transactNative(code, data, reply, flags);
7. Binder 跨进程数据传输   
  通过 copy_from_user 方法将数据从客户端进程 copy 到 《系统进程和服务端进程的共享内存中》
8. 服务端: Binder.execTransact 接收到跨进程数据 -> Binder.execTransactInternal -> Stub.onTransact
9.  Stub.onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) 通过 code 找到对应的方法，从 data 中读取调用方法的参数，执行方法调用，获取调用返回值写入 replay 
10. Binder 跨进程数据传输


### mmap (Memory Map)   
通常我们说的内存是虚拟内存，默认情况下系统会将虚拟内存映射到 RAM( 也就是内存条 )
我们平常操作文件的流程是，虚拟内存映射到 RAM 通过 read 方法从 Store 读取数据到虚拟内存，修改虚拟内存中的数据后，通过 write 方法将数写入到 Store 中。
使用 mmap 可以将虚拟内存直接映射到文件所在的 Store 位置,直接操作硬盘.无需再将文件读取到 RAM ,也不需要将数据从 RAM 写入到 Store

也可以将，两个进程的内存空间同时映射到同一块 RAM 或者 Store 中
##### mmap实现
mmap 的实现主要是先建立一个vm_area_struct的数据结构，这个数据结构表示了进程虚拟地址空间中的一段。然后这个结构把磁盘文件的区域和虚拟地址空间中的一段连接了起来

### (AIDL（Android Interface Definition Language）是什么)[https://developer.android.google.cn/guide/components/aidl.html?hl=zh-cn]
为实现跨进程进行通信，进程需将其对象分解成可供操作系统理解的原语，并将其编组为可供您操作的对象。编写执行该编组操作的代码较为繁琐，因此 Android 会使用 AIDL 为您处理此问题。
简单来说，AIDL是一种语言，这种语言可以用简单的AIDL语句，生成复杂的可用于跨进程的 Binder Java 类。（不使用AIDL 手写 Bindler 也是可以跨进程的，所以说真正用于跨进程的是 Binder 的实现，AIDL 只是生成这种实现的一种简便工具）

* AIDL 文件同一个interface 不可以有两个同名方法，即使参数不同也不可以




