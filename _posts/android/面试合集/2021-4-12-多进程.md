---
layout: post
author: "ooftf"
tags: Android
---

# Process
## 什么是进程
进程系统进行资源分配和调度的基本单位，是程序在内存中的实例;进程之间内存相互独立

## 多进程应用的优点
* Android 对单个进程是有内存大小限制的，多进程可以申请更多的总内存，减少单个进程占用内存的大小
* 进程间崩溃不会相互影响
* APP保活（前台进程优先级比较高；进程优先级越高、单个进程占用内存越小被杀死的优先级越小）
## 常见的多进程案例
* 将 WebView 放入单独进程
* 图片选择器放入单独进程
* 将功能比较独立的功能放入单个进程，比如 网络日志查看、崩溃日志查看等功能
## 多进程会存在那些问题
* 进程间内存相互独立，无法相互访问
    * ActivityLifeCycleCallbacks 只能拿到各自进程Activity的生命周期
    * 单例等静态资源会存在多份
    * 多进程会初始化多个Application
    * sp多进程无法及时同步
* 多进程在同时读写文件的时候会出问题
    * sp
    * db
    * 文件读写

* WebView cookie 问题
    * 原生 CookieManager cookie 可以同步
    * X5  CookieManger cookie 不可以
* A 进程 startActivity 新 Activity 在哪个进程中
    ```xml
    <activity android:multiprocess="true"> 
    ```
    * 默认情况下，未指定进程就是主进程，如果指定了进程就会指定进程中 
    * multiprocess = true 的情况下从哪个进程启动就存在于哪个进程 
  
* [SharePreferences跨进程](https://ooftf.github.io/2021/06/18/SharedPreferences/)
    解决方案 ContentProvider 或者 Binder 桥接 或者 MMKV

## Android IPC (Inter-Process Communication) 的几种方式
* Binder
    * ContentProvider（基于Binder）
    * Messenger  (轻量级AILD，使用方便)（基于Binder），如果不需要处理多线程，可以使用 Messenger 来实现接口;
* Intent
* 共享文件
* Socket
* 共享内存

6 种 IPC 方式优劣势比较

![6 种 IPC 方式优劣势比较](https://github.com/ooftf/ooftf.github.io/blob/master/images/ipc.jpg?raw=true)

### Messenger
Messenger 比使用 AIDL 更简单，因为 Messenger 会将所有服务调用加入队列。纯 AIDL 接口会同时向服务发送多个请求，那么服务就必须执行多线程处理。
对于大多数应用，服务无需执行多线程处理，因此使用 Messenger 可让服务一次处理一个调用。如果您的服务必须执行多线程处理，请使用 AIDL 来定义接口。

服务端代码
```kotlin
private const val MSG_SAY_HELLO = 1

class MessengerService : Service() {

    private lateinit var mMessenger: Messenger

    internal class IncomingHandler(
            context: Context,
            private val applicationContext: Context = context.applicationContext
    ) : Handler() {
        override fun handleMessage(msg: Message) {
            when (msg.what) {
                MSG_SAY_HELLO ->
                    Toast.makeText(applicationContext, "hello!", Toast.LENGTH_SHORT).show()
                else -> super.handleMessage(msg)
            }
        }
    }

    override fun onBind(intent: Intent): IBinder? {
        Toast.makeText(applicationContext, "binding", Toast.LENGTH_SHORT).show()
        mMessenger = Messenger(IncomingHandler(this))
        return mMessenger.binder
    }
}

```
客户端代码
```kotlin
class ActivityMessenger : Activity() {
    private var mService: Messenger? = null
    private var bound: Boolean = false
    private val mConnection = object : ServiceConnection {
        override fun onServiceConnected(className: ComponentName, service: IBinder) {
            mService = Messenger(service)
            bound = true
        }
        override fun onServiceDisconnected(className: ComponentName) {
            //当与服务的连接意外中断时，例如服务崩溃或被终止时，Android 系统会调用该方法。当客户端取消绑定时，系统不会调用该方法。
            mService = null
            bound = false
        }
    }
    fun sayHello(v: View) {
        if (!bound) return
        val msg: Message = Message.obtain(null, MSG_SAY_HELLO, 0, 0)
        try {
            mService?.send(msg)
        } catch (e: RemoteException) {
            e.printStackTrace()
        }

    }
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.main)
    }

    override fun onStart() {
        super.onStart()
        Intent(this, MessengerService::class.java).also { intent ->
            bindService(intent, mConnection, Context.BIND_AUTO_CREATE)
        }
    }

    override fun onStop() {
        super.onStop()
        if (bound) {
            unbindService(mConnection)
            bound = false
        }
    }
}
```

### Binder
* 同一个进程使用 Binder 可以使用 (service as LocalBinder).speak() 强转的方式，如果是不同进程使用强转就会报错 java.lang.ClassCastException: android.os.BinderProxy cannot be cast to xxx.xxx.xxx.LocalBinder
* 如果是同一进程中的 Binder 调用，调用处和被调用处在同一线程中，如果是跨进程调用，服务端是在 Binder 线程池中执行的
* AIDL方法是在服务端的 Binder 线程池中执行
* 如果知道服务端方法是耗时的，那么就要避免在客户端的UI线程中访问这个远程方法
* 使用了 一次 copy_from_user 和 mmap 完成的跨进程操作
  客户端将数据通过 copy_from_user Native 方法将数据从客户端进程 copy 到系统空间，然后通过 mmap 将系统空间和服务端进程 映射到同一块进程中。完成数据的传输


```java
/*
 * This file is auto-generated.  DO NOT MODIFY.
 */
package com.ooftf.demo.ipc.remote;
public interface IRemoteService extends android.os.IInterface
{
  // 这里是一个空实现，asBinder 也是返回的 null ，基本上用不到
  public static class Default implements com.ooftf.demo.ipc.remote.IRemoteService
  {
    @Override public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, java.lang.String aString) throws android.os.RemoteException
    {
    }
    @Override public void speak(com.ooftf.demo.ipc.data.ParcelableData message) throws android.os.RemoteException
    {
    }
    @Override public void register(com.ooftf.demo.ipc.remote.ICallback callback) throws android.os.RemoteException
    {
    }
    @Override public void unRegister(com.ooftf.demo.ipc.remote.ICallback callback) throws android.os.RemoteException
    {
    }
    @Override
    public android.os.IBinder asBinder() {
      return null;
    }
  }
  // 重写了 Binder.onTransact 方法，继承自 IRemoteService
  // onTransact 是进行跨进程的实现部分，客户端调用方法后，会进入0服务端 onTransact 然后根据传入的数据调用对应的方法
  // 用于户服务端方法实现
  public static abstract class Stub extends android.os.Binder implements com.ooftf.demo.ipc.remote.IRemoteService
  {
    private static final java.lang.String DESCRIPTOR = "com.ooftf.demo.ipc.remote.IRemoteService";

    public Stub()
    {
      this.attachInterface(this, DESCRIPTOR);
    }
    
    public static com.ooftf.demo.ipc.remote.IRemoteService asInterface(android.os.IBinder obj)
    {
      if ((obj==null)) {
        return null;
      }
      android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);
      if (((iin!=null)&&(iin instanceof com.ooftf.demo.ipc.remote.IRemoteService))) {
        return ((com.ooftf.demo.ipc.remote.IRemoteService)iin);
      }
      return new com.ooftf.demo.ipc.remote.IRemoteService.Stub.Proxy(obj);
    }
    @Override public android.os.IBinder asBinder()
    {
      return this;
    }
    @Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException
    {
      java.lang.String descriptor = DESCRIPTOR;
      switch (code)
      {
        case INTERFACE_TRANSACTION:
        {
          reply.writeString(descriptor);
          return true;
        }
        case TRANSACTION_basicTypes:
        {
          data.enforceInterface(descriptor);
          int _arg0;
          _arg0 = data.readInt();
          long _arg1;
          _arg1 = data.readLong();
          boolean _arg2;
          _arg2 = (0!=data.readInt());
          float _arg3;
          _arg3 = data.readFloat();
          double _arg4;
          _arg4 = data.readDouble();
          java.lang.String _arg5;
          _arg5 = data.readString();
          this.basicTypes(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5);
          reply.writeNoException();
          return true;
        }
        case TRANSACTION_speak:
        {
          data.enforceInterface(descriptor);
          com.ooftf.demo.ipc.data.ParcelableData _arg0;
          if ((0!=data.readInt())) {
            _arg0 = com.ooftf.demo.ipc.data.ParcelableData.CREATOR.createFromParcel(data);
          }
          else {
            _arg0 = null;
          }
          this.speak(_arg0);
          reply.writeNoException();
          return true;
        }
        case TRANSACTION_register:
        {
          data.enforceInterface(descriptor);
          com.ooftf.demo.ipc.remote.ICallback _arg0;
          _arg0 = com.ooftf.demo.ipc.remote.ICallback.Stub.asInterface(data.readStrongBinder());
          this.register(_arg0);
          reply.writeNoException();
          return true;
        }
        case TRANSACTION_unRegister:
        {
          data.enforceInterface(descriptor);
          com.ooftf.demo.ipc.remote.ICallback _arg0;
          _arg0 = com.ooftf.demo.ipc.remote.ICallback.Stub.asInterface(data.readStrongBinder());
          this.unRegister(_arg0);
          reply.writeNoException();
          return true;
        }
        default:
        {
          return super.onTransact(code, data, reply, flags);
        }
      }
    }
    // 客户端的代理对象，调用方法会打包成数据，调用 ServiceConnection.onServiceConnected 的参数 IBinder 的 onTransact 方法
    private static class Proxy implements com.ooftf.demo.ipc.remote.IRemoteService
    {
      private android.os.IBinder mRemote;
      Proxy(android.os.IBinder remote)
      {
        mRemote = remote;
      }
      @Override public android.os.IBinder asBinder()
      {
        return mRemote;
      }
      public java.lang.String getInterfaceDescriptor()
      {
        return DESCRIPTOR;
      }
      /**
           * Demonstrates some basic types that you can use as parameters
           * and return values in AIDL.
           */
      @Override public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, java.lang.String aString) throws android.os.RemoteException
      {
        android.os.Parcel _data = android.os.Parcel.obtain();
        android.os.Parcel _reply = android.os.Parcel.obtain();
        try {
          _data.writeInterfaceToken(DESCRIPTOR);
          _data.writeInt(anInt);
          _data.writeLong(aLong);
          _data.writeInt(((aBoolean)?(1):(0)));
          _data.writeFloat(aFloat);
          _data.writeDouble(aDouble);
          _data.writeString(aString);
          boolean _status = mRemote.transact(Stub.TRANSACTION_basicTypes, _data, _reply, 0);
          if (!_status && getDefaultImpl() != null) {
            getDefaultImpl().basicTypes(anInt, aLong, aBoolean, aFloat, aDouble, aString);
            return;
          }
          _reply.readException();
        }
        finally {
          _reply.recycle();
          _data.recycle();
        }
      }
      @Override public void speak(com.ooftf.demo.ipc.data.ParcelableData message) throws android.os.RemoteException
      {
        android.os.Parcel _data = android.os.Parcel.obtain();
        android.os.Parcel _reply = android.os.Parcel.obtain();
        try {
          _data.writeInterfaceToken(DESCRIPTOR);
          if ((message!=null)) {
            _data.writeInt(1);
            message.writeToParcel(_data, 0);
          }
          else {
            _data.writeInt(0);
          }
          boolean _status = mRemote.transact(Stub.TRANSACTION_speak, _data, _reply, 0);
          if (!_status && getDefaultImpl() != null) {
            getDefaultImpl().speak(message);
            return;
          }
          _reply.readException();
        }
        finally {
          _reply.recycle();
          _data.recycle();
        }
      }
      @Override public void register(com.ooftf.demo.ipc.remote.ICallback callback) throws android.os.RemoteException
      {
        android.os.Parcel _data = android.os.Parcel.obtain();
        android.os.Parcel _reply = android.os.Parcel.obtain();
        try {
          _data.writeInterfaceToken(DESCRIPTOR);
          _data.writeStrongBinder((((callback!=null))?(callback.asBinder()):(null)));
          boolean _status = mRemote.transact(Stub.TRANSACTION_register, _data, _reply, 0);
          if (!_status && getDefaultImpl() != null) {
            getDefaultImpl().register(callback);
            return;
          }
          _reply.readException();
        }
        finally {
          _reply.recycle();
          _data.recycle();
        }
      }
      @Override public void unRegister(com.ooftf.demo.ipc.remote.ICallback callback) throws android.os.RemoteException
      {
        android.os.Parcel _data = android.os.Parcel.obtain();
        android.os.Parcel _reply = android.os.Parcel.obtain();
        try {
          _data.writeInterfaceToken(DESCRIPTOR);
          _data.writeStrongBinder((((callback!=null))?(callback.asBinder()):(null)));
          boolean _status = mRemote.transact(Stub.TRANSACTION_unRegister, _data, _reply, 0);
          if (!_status && getDefaultImpl() != null) {
            getDefaultImpl().unRegister(callback);
            return;
          }
          _reply.readException();
        }
        finally {
          _reply.recycle();
          _data.recycle();
        }
      }
      public static com.ooftf.demo.ipc.remote.IRemoteService sDefaultImpl;
    }
    static final int TRANSACTION_basicTypes = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);
    static final int TRANSACTION_speak = (android.os.IBinder.FIRST_CALL_TRANSACTION + 1);
    static final int TRANSACTION_register = (android.os.IBinder.FIRST_CALL_TRANSACTION + 2);
    static final int TRANSACTION_unRegister = (android.os.IBinder.FIRST_CALL_TRANSACTION + 3);
    public static boolean setDefaultImpl(com.ooftf.demo.ipc.remote.IRemoteService impl) {
      // Only one user of this interface can use this function
      // at a time. This is a heuristic to detect if two different
      // users in the same process use this function.
      if (Stub.Proxy.sDefaultImpl != null) {
        throw new IllegalStateException("setDefaultImpl() called twice");
      }
      if (impl != null) {
        Stub.Proxy.sDefaultImpl = impl;
        return true;
      }
      return false;
    }
    public static com.ooftf.demo.ipc.remote.IRemoteService getDefaultImpl() {
      return Stub.Proxy.sDefaultImpl;
    }
  }
  /**
       * Demonstrates some basic types that you can use as parameters
       * and return values in AIDL.
       */
  public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, java.lang.String aString) throws android.os.RemoteException;
  public void speak(com.ooftf.demo.ipc.data.ParcelableData message) throws android.os.RemoteException;
  public void register(com.ooftf.demo.ipc.remote.ICallback callback) throws android.os.RemoteException;
  public void unRegister(com.ooftf.demo.ipc.remote.ICallback callback) throws android.os.RemoteException;
}

```
### mmap (Memory Map)   
通常我们说的内存是虚拟内存，默认情况下系统会将虚拟内存映射到 RAM( 也就是内存条 )
我们平常操作文件的流程是，虚拟内存映射到 RAM 通过 read 方法从 Store 读取数据到虚拟内存，修改虚拟内存中的数据后，通过 write 方法将数写入到 Store 中。
使用 mmap 可以将虚拟内存直接映射到文件所在的 Store 位置,直接操作硬盘.无需再将文件读取到 RAM ,也不需要将数据从 RAM 写入到 Store
##### mmap实现
mmap 的实现主要是先建立一个vm_area_struct的数据结构，这个数据结构表示了进程虚拟地址空间中的一段。然后这个结构把磁盘文件的区域和虚拟地址空间中的一段连接了起来

### (AIDL（Android Interface Definition Language）是什么)[https://developer.android.google.cn/guide/components/aidl.html?hl=zh-cn]
为实现跨进程进行通信，进程需将其对象分解成可供操作系统理解的原语，并将其编组为可供您操作的对象。编写执行该编组操作的代码较为繁琐，因此 Android 会使用 AIDL 为您处理此问题。
简单来说，AIDL是一种语言，这种语言可以用简单的AIDL语句，生成复杂的可用于跨进程的 Binder Java 类。（不使用AIDL 手写 Bindler 也是可以跨进程的，所以说真正用于跨进程的是 Binder 的实现，AIDL 只是生成这种实现的一种简便工具）

* AIDL 文件同一个interface 不可以有两个同名方法，即使参数不同也不可以




