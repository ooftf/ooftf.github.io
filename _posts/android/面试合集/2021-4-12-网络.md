---
layout: post
author: "ooftf"
tags: Android
---
# 网络
## TCP和UDP协议有什么不同
1. TCP是可靠的，有序的，面向链接的，传输数据较大，速度慢，具有数据重传机制，
2.  UDP是不可靠的，无序的，没有链接的，传输数据小，速度快，
3.  TCP一般用在文件传输，邮件等需要确保数据完整性，
4.  UDP一般用于实时应用，如QQ(由于tcp并发问题，选用udp再封装一层)，直播等
## Http协议
* （Hyper Text Transfer protocol）应用层，基于TCP/IP
* 问答模式
* 特点：简单快捷；灵活；无连接？；无状态  每次交互都是独立的
* 浏览器通常都会限制url长度在2K个字节

####  Requestj结构
1. 请求行  （请求类型，要访问的资源，以及所使用的版本）
2. 请求头    (Host,User-Agent,Content-Type,Content-Length,Connection(keep-Alive))
3. 空行，用来分隔请求头和请求主体
4. 请求主体
####  Response
1. 状态行（协议版本号，状态码，状态消息）  HTTP/1.1 200  OK
2. 消息报头
3. 空行
4. 响应正文
## [HTML请求方法](https://www.w3school.com.cn/tags/html_ref_httpmethods.asp)
*  GET
*  POST
*  PUT
*  HEAD
*  DELETE
*  PATCH
*  OPTIONS
#### GET
**GET 用于从指定资源请求数据。**  
**查询字符串（名称/值对）是在 GET 请求的 URL 中发送的：**
```
/test/demo_form.php?name1=value1&name2=value2
```
*  请求可被缓存
*  请求保留在浏览器历史记录中
*  请求可被收藏为书签
*  请求不应在处理敏感数据时使用
*  请求有长度限制
*  请求只应当用于取回数据（不修改）
#### POST
**POST 用于将数据发送到服务器来创建/更新资源。**  
**通过 POST 发送到服务器的数据存储在 HTTP 请求的请求主体中：**
```
POST /test/demo_form.php HTTP/1.1
Host: w3school.com.cn
name1=value1&name2=value2
```
*  请求不会被缓存
*  请求不会保留在浏览器历史记录中
*  不能被收藏为书签
*  请求对数据长度没有要求
#### PUT
**PUT 用于将数据发送到服务器来创建/更新资源。**  
POST 和 PU T之间的区别在于 PUT 请求是幂等的（idempotent）。也就是说，多次调用相同的 PUT 请求将始终产生相同的结果。相反，重复调用POST请求具有多次创建相同资源的副作用。
#### GET和POST有什么不同

* GET 用于从指定资源请求数据。
* GET请求数据是写在URL中的，POST请求数据是写在RequestBody中的
* 在标准规定下 GET 请求不允许携带RequestBody,如果RequestBody偷偷藏了数据，处不处理完全看服务器程序员习惯
* GET产生一个TCP数据包；POST产生两个TCP数据包。
    对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；
    而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。
    并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。
* GET是无副作用的，POST可能有副作用
**w3school GET和POST对比**
<table>
<tr>
<th>GET</th>
<th>POST</th>
</tr>

<tr>
<td>后退按钮/刷新</td>
<td>无害</td>
<td>数据会被重新提交（浏览器应该告知用户数据会被重新提交）。</td>
</tr>

<tr>
<td>书签</td>
<td>可收藏为书签</td>
<td>不可收藏为书签</td>
</tr>

<tr>
<td>缓存</td>
<td>能被缓存</td>
<td>不能缓存</td>
</tr>

<tr>
<td>编码类型</td>
<td>application/x-www-form-urlencoded</td>
<td>application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。</td>
</tr>

<tr>
<td>历史</td>
<td>参数保留在浏览器历史中。</td>
<td>参数不会保存在浏览器历史中。</td>
</tr>

<tr>
<td>对数据长度的限制</td>
<td>是的。当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。</td>
<td>无限制。</td>
</tr>

<tr>
<td>对数据类型的限制</td>
<td>只允许 ASCII 字符。</td>
<td>没有限制。也允许二进制数据。</td>
</tr>

<tr>
<td>安全性</td>
<td><p>与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。</p>
<p>在发送密码或其他敏感信息时绝不要使用 GET ！</p></td>
<td>POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。</td>
</tr>

<tr>
<td>可见性</td>
<td>数据在 URL 中对所有人都是可见的。</td>
<td>数据不会显示在 URL 中。</td>
</tr>
</table>

## OkHttp
#### Okhttp优点
* HTTP/2 support allows all requests to the same host to share a socket.
* Connection pooling reduces request latency (if HTTP/2 isn’t available).
* Transparent GZIP shrinks download sizes.
* Response caching avoids the network completely for repeat requests.
* 方便的API
* 易扩展性，
* 完整的生态

## retrofit

## [SSL](http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html)

#### 解决的问题
1. 窃听风险（eavesdropping）：第三方可以获知通信内容。
2. 篡改风险（tampering）：第三方可以修改通信内容。
3. 冒充风险（pretending）：第三方可以冒充他人身份参与通信。

#### SSL过程
1. 当你的浏览器向服务器请求一个安全的网页(通常是 https://)
2. 服务器就把它的证书和公匙发回来
3. 浏览器检查证书是不是由可以信赖的机构颁发的，确认证书有效和此证书是此网站的。
4. 浏览器中随机生成一对对称秘钥，并使用公钥（服务器端的）加密该对称秘钥，将它和对称加密后的URL一起发送到服务器
5. 服务器用自己的私匙解密了你发送的钥匙。然后用这把对称加密的钥匙给你请求的URL链接解密。
6. 服务器用你发的对称钥匙给你请求的网页加密。你也有相同的钥匙就可以解密发回来的网页了

#### 相关思考
1. 为什么要用非对称加密
    窃听风险，如果采用对称加密，如果并且密码被窃听到，那么通话内容就会被破解。如果采用非对称加密，那么即使第三者拿到公钥也无法得到对话内容
3. CA解决了什么问题
    冒充风险，CA证书能确定通话对象是域名所对应的对象
4. 为什么采用非对称加密和对称加密结合的方式
    为了提高性能，对称密钥要比非对称加密算法更容易计算。用非对称加密交换对称加密的密钥保证了对称加密密钥的安全性，所以用非对称加密内容也是安全的
5.  为什么CA证书能确定目标身份

