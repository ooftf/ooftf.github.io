---
layout: post
author: "ooftf"
tags: Android
top: true
---
# Java内存模型（Java Memory Model，JMM）
## JMM的由来

由于计算机的储存设备与处理器的运算速度有着几个数量级的差距，所以现代计算机系统都不得不加入一层或多层读写速度尽可能接近处理器运算速度的的高速缓存（Cache）来作为内存与处理器之间的的缓冲：将运算所需要的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无需等待缓慢的内存读写

![CPU](https://github.com/ooftf/ooftf.github.io/blob/master/images/merroy_cup_cache.png?raw=true)

Java中的“内存模型”可以理解为对硬件层“基于高速缓存的储存交互”的一种抽象，高速缓存对应工作内存，共享主内存对应主内存

![CPU](https://github.com/ooftf/ooftf.github.io/blob/master/images/JMM.png?raw=true)

## 主内存与工作内存间的交互操作
“交互操作”具体是指，一个变量如何从主内存拷贝到工作内存、如何从从工作内存同步回主内存的实现细节。Java内存定义了一下8种操作来完成
1. lock（锁定）
2. unlock（解锁）
3. read（读取）
4. load（载入）
5. use（使用）
6. assign（赋值）
7. store（储存）
8. write（写入）

## 缓存一致性问题

基于高速缓存的储存交互很好地解决了处理器与内存速度之间的矛盾，但也引入了一个新的问题：缓存一致性，每个处理器都有自己的高速缓存，而他们又共享同一主内存，当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致。



## 指令重排序问题
为了使得处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行（Out-Of-Order Execution）优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致。因此，如果存在一个计算任务依赖另一个计算任务的中间结果，那么其顺序性并不能靠代码的先后顺序来保证。与处理器的乱序执行优化类似，Java虚拟机的即时编译器中也有类似的指令重排序（Instruction Reorder）优化




## 可见性
除了Volatile之外，Java还有两个关键字能实现可见性
* synchronized

    同步代码块的可见性是由“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）” 这条规则获得的。
* final

    final关键字的可见性是指：被final修饰的字段在构造器中一旦被初始化完成，并且构造器没有把“this”的引用传递出去（this引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象），那么在其他线程中就能看见final字段的值。   

## Java内存模型对Volatile变量定义的特殊规则
1. use前必定是load，load后续必定是use，两者绑定在一起
   
    这条规则要求在工作内存中内次使用Volatile变量前都必须先从主内存刷新最新的值，用于保证能看见其他线程对Volatile变量的修改
2. assign后必定是store，store前必定是assign，两者绑定在一起

    这题哦按规则要求在工作内存中，每次修改Volatile变量后都必须立刻同步回主内存，用于报证其他线程可以看到自己对Volatile变量所做的修改
3. （原规则很难描述）
    Volatile变量不会被指令重排序优化，从而保证代码的执行顺序与程序的顺序相同
### Volatile 在汇编语言层次 是如何实现了Java内存模型对Volatile变量定义的规则呢？
Volatile变量赋值后会多执行一个lock空操作（这个lock不是主内存与工作内存交互的lock而是汇编指令lock），这个操作的作用相当于一个内存屏障（Merrory Barrier 或 Merrory Fence，指令重排序时不能把后面的指令重排序到内存屏障之前的位置）。
Lock指令的作用时将本处理器的缓存写入了主内存，该写入动作也会引起别的处理器或者内核缓存无效化。所以通过这个lock空操作，可以让volatile变量的修改对其他处理器立刻可见。

#### 汇编指令 lock 在硬件层是如何实现的呢
通过 MESI 缓存一致性协议

