
# Java内存模型（Java Memory Model，JMM）
## JMM的由来

由于计算机的储存设备与处理器的运算速度有着几个数量级的差距，所以现代计算机系统都不得不加入一层或多层读写速度尽可能接近处理器运算速度的的高速缓存（Cache）来作为内存与处理器之间的的缓冲：将运算所需要的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无需等待缓慢的内存读写
![CPU](https://github.com/ooftf/ooftf.github.io/blob/master/images/merrory_cup_cache.png?raw=true)
Java中的“内存模型”可以理解为对硬件层“基于高速缓存的储存交互”的一种抽象，高速缓存对应工作内存，共享主内存对应主内存
![CPU](https://github.com/ooftf/ooftf.github.io/blob/master/images/JMM.png?raw=true)


## 缓存一致性问题

基于高速缓存的储存交互很好地解决了处理器与内存速度之间的矛盾，但也引入了一个新的问题：缓存一致性，每个处理器都有自己的高速缓存，而他们又共享同一主内存，当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致。



## 指令重排序问题
为了使得处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行（Out-Of-Order Execution）优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致。因此，如果存在一个计算任务依赖另一个计算任务的中间结果，那么其顺序性并不能靠代码的先后顺序来保证。与处理器的乱序执行优化类似，Java虚拟机的即时编译器中也有类似的指令重排序（Instruction Reorder）优化