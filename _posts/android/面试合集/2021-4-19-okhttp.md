## Okhttp 网络请求流程
1. 构建HttpClient
2. 构建Request
3. 生成Call对象
4. 发起请求execute()或enqueue()
    * execute  
    调用添加到 Dispatcher  runningSyncCalls 中，然后调用getResponseWithInterceptorChain()执行网络请求
    * enqueue  
    将Callback封装成AsyncCall，调用 Dispatcher enqueue方法，将AsyncCall 添加到 readyAsyncCalls，获取到当前host请求数量，添加到AsyncCall；调用promoteAndExecute()尝试执行；从readyAsyncCalls中遍历等待请求的AsyncCall，判断正在进行的网络请求个数是否>=maxRequests（默认64），如果>=结束循环。如果没有判断当前AsyncCall callsPerHost（默认5）是否大于maxRequestsPerHost 如果>= 结束本次循环，执行下一个 AsyncCall，
    如果有符合上述两个条件的AsyncCall，从 readyAsyncCalls 移除； callsPerHost 加一；添加到 runningAsyncCalls，添加到局部变量executableCalls中
    使用线程池executorService 遍历执行executableCalls
    AsyncCall.run  调用 getResponseWithInterceptorChain() 获取都response 回调给 Callback，最终调用dispatcher.finished(this)结束本次调用


有上述流程可知promoteAndExecute是用来尝试执行等待队列符合条件的AsyncCall,一共有四处调用
1. Dispatcher.enqueue
2. Dispatcher.finished
3. setMaxRequests
4. setCallsPerHost

无论是异步请求还是同步请求，真正的网络请求网络请求是在getResponseWithInterceptorChain()中执行的
1. 装载拦截器
```kotlin
    val interceptors = mutableListOf<Interceptor>()
    interceptors += client.interceptors
    interceptors += RetryAndFollowUpInterceptor(client)
    interceptors += BridgeInterceptor(client.cookieJar)
    interceptors += CacheInterceptor(client.cache)
    interceptors += ConnectInterceptor
    if (!forWebSocket) {
      interceptors += client.networkInterceptors
    }
    interceptors += CallServerInterceptor(forWebSocket)
```

2. 执行拦截器责任链
```
  val chain = RealInterceptorChain(
        call = this,
        interceptors = interceptors,
        index = 0,
        exchange = null,
        request = originalRequest,
        connectTimeoutMillis = client.connectTimeoutMillis,
        readTimeoutMillis = client.readTimeoutMillis,
        writeTimeoutMillis = client.writeTimeoutMillis
    )
  val response = chain.proceed(originalRequest)
```
从上述代码可知，系统先执行用户自定义拦截器又执行的Okhttp自带的五个系统拦截器

#### 系统拦截器
* RetryAndFollowUpInterceptor
* BridgeInterceptor
* CacheInterceptor
* ConnectInterceptor
* CallServerInterceptor

#### AsyncCall 异步请求Call封装
* 网络回调 responseCallback
* callsPerHost
* request
* call
* 实现了Runnable
#### readyAsyncCalls 异步等待队列


### Dispatcher 调度器
* 决定了网络请求的执行时机和执行线程，管理最大可执行任务数和每个Host最大可执行任务数
* 三个任务集合
    1. readyAsyncCalls （异步等待集合）
    2. runningAsyncCalls （正在执行的异步网络请求集合）
    3. runningSyncCalls （正在执行的同步网络请求集合）
* 线程池executorService
   ```kotlin
      ThreadPoolExecutor(0, Int.MAX_VALUE, 60, TimeUnit.SECONDS,
                  SynchronousQueue(), threadFactory("$okHttpName Dispatcher", false))
            }
   ```    