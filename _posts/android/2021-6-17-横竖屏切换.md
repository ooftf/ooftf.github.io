# 默认情况下横竖屏切换走的是
ActivityThread.handleRelaunchActivity
```java
@Override
public void handleRelaunchActivity(ActivityClientRecord tmp,
        PendingTransactionActions pendingActions) {
    Configuration changedConfig = null;
    int configChanges = 0;
    synchronized (mResourcesManager) {
        if (mPendingConfiguration != null) {
            changedConfig = mPendingConfiguration;
            mPendingConfiguration = null;
        }
    }
    if (changedConfig != null) {
        handleConfigurationChanged(changedConfig, null);// 最终可能会调用 activity.onConfigurationChanged(configToReport); 默认情况下 Configuration.diffPublicOnly 计算没有修改，所以不会触发  onConfigurationChanged
    }
    ActivityClientRecord r = mActivities.get(tmp.token);
    r.activity.mConfigChangeFlags |= configChanges;
    r.mPreserveWindow = tmp.mPreserveWindow;
    r.activity.mChangingConfigurations = true;

    handleRelaunchActivityInner(r, configChanges, tmp.pendingResults, tmp.pendingIntents,
            pendingActions, tmp.startsNotResumed, tmp.overrideConfig, "handleRelaunchActivity");
}
```
ActivityThread.handleRelaunchActivityInner
```java
    /**
    * 从代码可以了解到内部执行了 performPauseActivity callActivityOnStop handleDestroyActivity 等方法，所以 Activity 会走一遍销毁的生命周期；
    * 最后会调用 handleLaunchActivity 方法重新创建一个Activity，走一遍启动 Activity 的生命周期 
    */
  private void handleRelaunchActivityInner(ActivityClientRecord r, int configChanges,
            List<ResultInfo> pendingResults, List<ReferrerIntent> pendingIntents,
            PendingTransactionActions pendingActions, boolean startsNotResumed,
            Configuration overrideConfig, String reason) {
        final Intent customIntent = r.activity.mIntent;
        if (!r.paused) {
            performPauseActivity(r, false, reason, null /* pendingActions */);
        }
        if (!r.stopped) {
            callActivityOnStop(r, true /* saveState */, reason);
        }

        handleDestroyActivity(r.token, false, configChanges, true, reason);

        r.startsNotResumed = startsNotResumed;
        r.overrideConfig = overrideConfig;

        handleLaunchActivity(r, pendingActions, customIntent);
    }
```
ActivityThread.handleDestroyActivity
```java
    @Override
    public void handleDestroyActivity(IBinder token, boolean finishing, int configChanges,
            boolean getNonConfigInstance, String reason) {
        // destroy activity        
        ActivityClientRecord r = performDestroyActivity(token, finishing,
                configChanges, getNonConfigInstance, reason);
                  WindowManager wm = r.activity.getWindowManager();
        wm.removeViewImmediate(v);// 这个地方最终会调用 Activity.onDetachedFromWindow
        ActivityTaskManager.getService().activityDestroyed(token); 
    }
```
ActivityThread.performDestroyActivity
```java
    ActivityClientRecord performDestroyActivity(IBinder token, boolean finishing,
            int configChanges, boolean getNonConfigInstance, String reason) {
        ActivityClientRecord r = mActivities.get(token);
        Class<? extends Activity> activityClass = null;
         r.activity.mFinished = true;
         // 如果是横竖屏切换 会调用 retainNonConfigurationInstances 获取需要保留的数据
            if (getNonConfigInstance) {
                 r.lastNonConfigurationInstances
                            = r.activity.retainNonConfigurationInstances();
            }
            mInstrumentation.callActivityOnDestroy(r.activity); // 调用 Acitvity.OnDestroy
            r.setState(ON_DESTROY);
        synchronized (mResourcesManager) {
            mActivities.remove(token);
        }
        return r;
    }
```