## 主流程分析

代码使用的是我手写代码，逻辑和 RxJava 一致，细节不同，先分析主流程

### Observable
```kotlin
abstract class Observable<T> {
    fun subscribe(observable: Observer<T>) {
        subscribeActual(observable)
    }
    protected abstract fun subscribeActual(observer:Observer<T>)
    companion object {
        fun <T> create(oos:ObservableOnSubscribe<T>): Observable<T> {
            return ObservableCreate<T>(oos)
        }
    }
}
```
总结：
* Observable 是被观察对象，提供 subscribe 用于“被订阅” 
* 对外提供静态方法 create ，用于创建 Observable 对象；
* create 方法的入参是 ObservableOnSubscribe 可以被称作为数据源，其作用是使用发射器 Emitter 发射数据
* 最终返回的是 ObservableCreate 对象，各个组件的粘合就是在 ObservableCreate 中完成的

### ObservableCreate

```kotlin
class ObservableCreate<T>(val source: ObservableOnSubscribe<T>) : Observable<T>() {

    override fun subscribeActual(observer: Observer<T>) {
        val emitter = CreateEmitter(observer)
        observer.onSubscribe(emitter)
        source.subscribe(emitter)
    }

}
```
总结：
* 当使用 subscribe 订阅事件的时候，就会调用 subscribeActual
* subscribeActual 内部首先创建 CreateEmitter 对象，触发 Observer.onSubscribe 事件
* 调用 ObservableOnSubscribe.subscribe 方法，传入 Emitter 发射器，ObservableOnSubscribe.subscribe 内部会使用 Emitter 发射数据

### CreateEmitter
```kotlin
class CreateEmitter<T>(val observer: Observer<T>) : Emitter<T>, Disposable {
    var disposed = false
    override fun onError(e: Throwable) {
        if (!isDisposed()) {
            observer.onError(e)
            dispose()
        }
    }

    override fun onNext(item: T) {
        if (!isDisposed()) {
            observer.onNext(item)
        }

    }

    override fun onComplete() {
        if (!isDisposed()) {
            observer.onCompleted()
            dispose()
        }

    }

    override fun dispose() {
        disposed = true
    }

    override fun isDisposed(): Boolean {
        return disposed
    }

}
```
* CreateEmitter 用于将 onNext、onError、onComplete 等事件经过 isDisposed 判断后转交给 Observer
* 通过这个代码我们可以知道 Disposable.disposed 只是防止 Observer 接收事件，并不能切断引用链，CreateEmitter 仍然持有 Observer 的对象，因此 disposed 并不能解决内存泄漏问题

## 以 map 为代表分析操作符（手写代码，非源代码）

* 添加方法 Observable.map
* 添加类 ObservableMap：此处使用装饰器模式，对上游原 Observable 进行封装拓展，重写 subscribeActual 订阅上游 Observable
* 添加类 ObserverMap 从上游 Observable 拿到数据，经过 mapper 转换，传输到下游 observer 中


```kotlin
fun <R> Observable.map(mapper: (T) -> R): Observable<R> {
    return ObservableMap(this, mapper)
}

class ObservableMap<T, R>(val upObservable: Observable<T>, val mapper: (T) -> R) : Observable<R>() {

    override fun subscribeActual(observer: Observer<R>) {
        upObservable.subscribe(ObserverMap(observer, mapper))
    }
}

class ObserverMap<U,D>(val observer:Observer<D>,val mapper:(U)->D):Observer<U>,Disposable {
    var upDisposable: Disposable? = null
    override fun onError(t: Throwable) {
        observer.onError(t)
    }

    override fun onNext(t: U) {
        observer.onNext(mapper.invoke(t))
    }

    override fun onCompleted() {
        observer.onCompleted()
    }

    override fun onSubscribe(disposable: Disposable) {
        upDisposable = disposable
        observer.onSubscribe(this)
    }

    override fun dispose() {
        upDisposable?.dispose()
    }

    override fun isDisposed(): Boolean {
        return upDisposable?.isDisposed() == true
    }
}
```

## 线程切换分析

## doOnNext 等方法分析



