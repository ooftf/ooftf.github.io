---
layout: post
author: "ooftf"
tags: Android
---

## kotlin关键字
* abstract	抽象声明，被标注对象默认是open
* annotation	注解声明
* by	类委托、属性委托
* class	声明类
* companion	伴生对象声明
* const	声明编译期常量
* constructor	声明构造函数
* data	数据类，声明的类默认实现equals()/hashCode()/toString/copy()/componentN()
* enum	声明枚举类
* field	属性的幕后字段
* fun	声明函数
* import	导入
* in	修饰类型参数，使其逆变：只可以被消费而不可以被生产
* init	初始化块；相当于主构造函数的方法体
* inner	标记嵌套类，使其成为内部类：可访问外部类的成员
* interface	声明接口
* internal	可见性修饰符，相同模块内可见
* lateinit	延迟初始化，避免空检查
* object	对象表达式、对象声明
* open	允许其它类继承；kotlin类默认都是final，禁止继承
* out	修饰类型参数，使其协变：只可以被生产而不可以被消费
* override	标注复写的方法、属性
* package	包声明
* private	可见性修饰符，文件内可见
* protected	可见性声明，只修饰类成员，子类中可见
* public	kotlin默认的可见性修饰符，随处可见
* super	访问超类的方法、属性
* throw	抛异常
* val	声明只读属性
* var	声明可变属性
* vararg	修饰函数参数：声明为可变数量参数
* **inline**	声明内联函数
* **noinline**	禁用内联，标记内联函数不需要内联的参数
* **operator**	标记重载操作符的函数
* [suspend](#coroutines)	声明挂起函数，该函数只能从协程和其他挂起函数中调用
* **reified**	限定类型参数，需要配合inline关键字使用
* **sealed**	声明密封类，功能类似枚举
* **typealias**	声明类型别名
* **crossinline**	标记内联函数的lambda表达式参数，标识该lambda函数返回为非局部返回，不允许非局部控制流
#### inline
* inline 的工作原理就是将内联函数的函数体复制到调用处实现内联。
  ```kotlin
    inline fun inlined(getString: () -> String?) = println(getString())
    fun notInlined(getString: () -> String?) = println(getString())
    fun test() {
      var testVar = "Test"
      notInlined { testVar }
      inlined { testVar }
    }
  ```
  反编译成Java代码
  ```java
    public static final void test() {
        final ObjectRef testVar = new ObjectRef();
        testVar.element = "Test Variable";
    
        // notInlined:
        notInlined((Function0)(new Function0(0) {
            public Object invoke() {
                return this.invoke();
            }
            @NotNull
            public final String invoke() {
               return (String)testVar.element;
            }
        }));
    
        // inlined:
        String var3 = (String)testVar.element;
        System.out.println(var3);
    }
  ```
* 不应该内联所有功能。而且官方也不建议这样做。Kotlin 贡献者的建议，原文是：「Functions should only be made inline when they use inline-only features like inlined lambda parameters or reified types.」意思就是说：inline 关键字应该只用在需要内联特性的函数中，比如高阶函数作为参数和具体化的类型参数时。

#### operator
* 运算符重载就是对已有的运算符赋予他们新的含义。重载的修饰符是operator
* 运算符重载实际上是函数重载，本质上是对运算符函数的调用，从运算符到对应函数的映射过程由编译器完成。
* 示例
  ```kotlin
  data class Person(var name: String, var age: Int){
      operator fun plus(other:Person):Person{
           return Person(this.name+"+"+other.name,this.age+other.age)
      }
  }
  fun main() {
   
      var person1=Person("A",3)
      var person2=Person("B",4)
      var person3=person1+person2
      println("person3=$person3")
  }
   //输出结果
  person3=Person(name=A+B, age=7)
  ```
* 我的理解：对 kotlin 具有特殊意义的一些函数进行函数重载需要添加  operator 比如 invoke 、 plus 等

#### reified
#### sealed
#### typealias
#### crossinline
## 一些概念
* 闭包
* 高阶函数
* DSL
* 带接收者的lambda
* init方法
* apply等方法
* [invoke约定](https://www.jianshu.com/p/e802954a0695)
* 扩展函数
* inline内联
* [函数库](https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/src/kotlin/util/Standard.kt)
* 协变和逆变
* 协程
## 闭包
* [参考文章](https://blog.csdn.net/yzzst/article/details/74619101)
* 如何在外部调取局部的变量呢？答案就是——闭包。闭包就是能够读取其他函数内部变量的函数
  ```kotlin
      //这是一个返回值为一个函数的高阶函数
      fun makeFun():()->Unit{
          var conut = 0
          return fun(){   //返回一个匿名函数，这个函数持有count的状态
              println(++conut)
          }
      }
  
      fun main() {
          val returnFun = makeFun() //函数调用，返回一个函数
          returnFun()       //调用这个返回的函数，此时makeFun持有makeFun()内部变量的状态
          returnFun()
          returnFun()
      }
  ```
  运行结果：  
  1  
  2  
  3
* 广义上来说，在Kotlin语言之中，函数、条件语句、控制流语句、花括号逻辑块、Lambda表达式都可以称之为闭包，但通常情况下，我们所指的闭包都是在说Lambda表达式。
* 函数可以作为变量的经典示例
  1. args.forEach(::println)
  2. 双冒号获取函数对象
     ```kotlin
       class MyLogger(val tag: String) {
         fun print(i: Int) {
             println("$tag  $i")
         }
       }
       fun main(args: Array<String>) {
           val arr = intArrayOf(1, 2, 4, 6)
           arr.forEach(MyLogger("TAG")::print)
       }
     ```
  3. 声明一个函数并赋值
     ```kotlin
       var oneFun: () -> Unit = fun() {
           
       }
     ```
  4. 闭包
     ```kotlin
       fun aaa(): () -> (Int) {
           var current = 10
           return fun(): Int {
               return current++
           }
       }
     ```

## 高阶函数
* 定义：将函数用作一个函数的参数或者返回值的函数。
* 示例
  ```
  public inline fun <T> Iterable<T>.forEach(action: (T) -> Unit): Unit {
      for (element in this) action(element)
  }
  ```
  分析：forEach的参数为一个函数，所以forEach为一个高阶函数

## [DSL](https://www.jianshu.com/p/e802954a0695)
## 带接收者的lambda
声明一个 lambda 表达式时，参数后面添加 .() 例如 String.() -> Unit ,那么函数实例作用域内的 this 为 String 的实例对象
* 经典示例apply
  public inline fun <T> T.apply(block: T.() -> Unit): T {
      contract {
          callsInPlace(block, InvocationKind.EXACTLY_ONCE)
      }
      block()
      return this
  }
## kotlin跳出循环
```kotlin
//跳出本次循环，功能类似于continue
(0..10).forEachIndexed { index, it ->
        println("-- forEach -- ${index} --")
    	if (it > 5) return@forEachIndexed
    	println(it)
  	}
//跳出整个循环，功能类似于break
run outside@{
    (0..10).forEachIndexed { index, it ->
        println("-- forEach -- ${index} --")
        if (it > 5) return@outside
        println(it)
    }
}
```
##  be careful
* 在kotlin项目中 注解处理器要使用kapt代替annotationProcessor，annotationProcessor（可能会失效？）  
  添加 apply plugin: 'kotlin-kapt'
* databinding 在布局中条用 kotlin 伴生类的方法，调用不到（使用@JvmStatic）
* kotlin   ARouter在autowired 的变量要添加@JvmFiled

## 创建数组迭代器
(0..10) 表示[0,10]  
(0 until 10)表示[0,10)
## init{} 执行时机
是在kotlin constructor构造方法之前调用，翻译成Java代码就是插入到构造方法的第一行然后才执行kotlin构造方法
```kotlin
class Person() {
    private var gender: Boolean = true
    constructor(name: String,gender: Boolean):this() {
        println("constructor")
    }
    init {
        println("Person init 2,gender:${gender}")
    }
    init {
        println("Person init 1")
    }
}
```
执行结果：  
Person init 2,gender:true  
Person init 1  
constructor

<h2 id = "coroutines">协程</h2>

* 官方描述：协程通过将复杂性放入库来简化异步编程。程序的逻辑可以在协程中顺序地表达，而底层库会为我们解决其异步性。该库可以将用户代码的相关部分包装为回调、订阅相关事件、在不同线程（甚至不同机器）上调度执行，而代码则保持如同顺序执行一样简单。
* 协程很重要的一点就是当它挂起的时候，它不会阻塞其他线程。协程底层库也是异步处理阻塞任务，但是这些复杂的操作被底层库封装起来，协程代码的程序流是顺序的，不再需要一堆的回调函数，就像同步代码一样，也便于理解、调试和开发。它是可控的，线程的执行和结束是由操作系统调度的，而协程可以手动控制它的执行和结束。

#### 代码分析
##### 关键类和方法
* GlobalScope:launch
* runBlocking
* launch:Job
  * job.isActive
  * job.isCancelled
  * job.isCompleted
  * job.cancel()
  * jon.join()
* GlobalScope:async
* Deferred.await()
* withContext

```kotlin
    val asyncTask = GlobalScope.async {
            Log.e("coroutines", "EEE-${Thread.currentThread().name}")
            delay(5000)
            Log.e("coroutines", "FFF-${Thread.currentThread().name}")
        }
    fun mainThread() {
        Log.e("coroutines", "000-${Thread.currentThread().name}")
        GlobalScope.launch(Dispatchers.IO) {
           Log.e("coroutines", "AAA-${Thread.currentThread().name}")
            suspendFun()
            Log.e("coroutines", "CCC-${Thread.currentThread().name}")
            asyncTask.await()
            Log.e("coroutines", "GGG-${Thread.currentThread().name}")
        }.start()
        Log.e("coroutines", "DDD-${Thread.currentThread().name}")
    }

    suspend fun suspendFun() {
        withContext(Dispatchers.Main) {
            Log.e("coroutines", "BBB-${Thread.currentThread().name}")
        }
    }
 /* 
    运行结果：
    EEE-DefaultDispatcher-worker-1
    000-main
    DDD-main
    AAA-DefaultDispatcher-worker-1
    BBB-main
    CCC-DefaultDispatcher-worker-2
    FFF-DefaultDispatcher-worker-1
    GGG-DefaultDispatcher-worker-1
    */
```
* 从 000 后面执行的是 DDD 得知launch并没有阻塞主线程执行，即使是改为GlobalScope.launch(Dispatchers.Main)得到的结果也是一样的;这个特性和 runBlocking 相反
* 从AAA BBB CCC的执行顺序可知，BBB 虽然和 AAA CCC 不在同一个线程执行顺序却是按照 AAA BBB CCC 的代码顺序执行的，这就是所谓的挂起函数
* AAA 和 CCC 虽然在代码中属于同一块代码，确是在不同的线程中执行的。
* AAA 和 CCC 可能在同一线程执行也可能在不同线程执行
