---
published: false
---

## 类加载的七个阶段
1. 加载
2. 验证
3. 准备
4. 解析
5. 初始化
6. 使用
7. 卸载

![类加载的七个阶段](https://raw.githubusercontent.com/ooftf/Material/master/img/blog/1628348095.png)


### 加载
#### 触发类加载的时机
1. 使用 new 关键字实例化对象
2. 读取或设置一个类型的静态字段的时候（被 final 修饰、已在编译器把结果放入常量池的静态字段除外）
3. 调用一个类型的静态方法方法的时候
4. 使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需
要先触发其初始化。
5. 当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
6. 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先
初始化这个主类。
7. 当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解
析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句
柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。
8. 当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有
这个接口的实现类发生了初始化，那该接口要在其之前被初始化。

#### 在加载阶段，Java虚拟机需要完成以下三件事情：

1. 通过一个类的全限定名来获取定义此类的二进制字节流。
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入
口。

### 双亲委派机制

如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加
载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的
加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请
求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。


### Android中一共有三种类加载器
1. BootClassLoader
    用来加载系统的类，例如String Activity
2. PathClassLoader
    用来加载Apk内部的类，例如XXXActivity
2. DexClassLoader
    可以用来加载Apk外部，指定Dex中的类

### 双亲委派机制的目的
* 为了系统安全，保证Activity等系统类是由 BootClassLoader 加载
* 为了保证一个类只加载一次

### 如何加载系统Apk外部类
```kotlin
DexClassLoader("", "", "", classLoader)
```
上面的方式就会将DexClassLoader添加为classLoader的子节点